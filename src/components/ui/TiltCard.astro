---
interface Props {
  class?: string;
  maxTilt?: number;
  scale?: number;
  perspective?: number;
}

const {
  class: className = "",
  maxTilt = 10,
  scale = 1.02,
  perspective = 1000,
} = Astro.props;
---

<div
  class:list={["tilt-card", className, "contain-layout"]}
  data-max-tilt={maxTilt}
  data-scale={scale}
  data-perspective={perspective}
  style="contain: layout style;"
>
  <div class="tilt-shine"></div>
  <slot />
</div>

<script>
  /**
   * ⚡ Bolt: TiltCard performance optimization
   * - Lazy listener attachment: 'mousemove' is only attached during interaction
   * - Caches DOM references
   * - RAF throttling
   */
  function initTiltCards() {
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

    const cards = document.querySelectorAll(
      ".tilt-card:not(.tilt-initialized)",
    );

    cards.forEach((card) => {
      const el = card as HTMLElement;
      const maxTilt = Number(el.dataset.maxTilt) || 10;
      card.classList.add("tilt-initialized");

      // ⚡ Cache the style object reference to avoid repeated lookups
      const cardStyle = el.style;

      // ⚡ Bolt: Cache layout metrics (document-relative)
      let width = 0;
      let height = 0;
      let left = 0;
      let top = 0;
      let frameId: number | null = null;
      let targetX = 0;
      let targetY = 0;

      function update() {
        if (width === 0 || height === 0) return;

        // ⚡ Pre-calculate center coordinates using cached dimensions
        const centerX = width * 0.5;
        const centerY = height * 0.5;

        // ⚡ Calculate relative position using document-relative coordinates
        // This avoids layout thrashing from getBoundingClientRect() and fixes scroll drift
        const relativeX = targetX - left - centerX;
        const relativeY = targetY - top - centerY;

        // ⚡ Calculate rotation with division by center values
        const rotateX = (relativeY / centerY) * -maxTilt;
        const rotateY = (relativeX / centerX) * maxTilt;

        // ⚡ Set CSS custom properties using cached style reference
        cardStyle.setProperty("--rotate-x", `${rotateX}deg`);
        cardStyle.setProperty("--rotate-y", `${rotateY}deg`);

        frameId = null;
      }

      function onMouseMove(e: MouseEvent) {
        if (width === 0 || height === 0) return;

        // ⚡ Use pageX/Y to get document-relative coordinates
        // This is robust against scrolling and avoids layout reads
        targetX = e.pageX;
        targetY = e.pageY;

        // ⚡ Use requestAnimationFrame to throttle visual updates
        if (!frameId) {
          frameId = requestAnimationFrame(update);
        }
      }

      function onMouseLeave() {
        // ⚡ Cancel pending frame
        if (frameId) {
          cancelAnimationFrame(frameId);
          frameId = null;
        }

        // ⚡ Reset styles
        cardStyle.setProperty("--rotate-x", "0deg");
        cardStyle.setProperty("--rotate-y", "0deg");
        // ⚡ Bolt: Remove will-change to save GPU memory when not interacting
        cardStyle.removeProperty("will-change");

        // ⚡ Bolt: Remove layer promotion to save GPU memory
        cardStyle.willChange = "auto";

        // Reset metrics
        width = 0;
        height = 0;

        // ⚡ Bolt: Cleanup high-frequency listeners when not needed
        card.removeEventListener("mousemove", onMouseMove);
        card.removeEventListener("mouseleave", onMouseLeave);
      }

      function onMouseEnter() {
        // ⚡ Bolt: Promote to composite layer only on interaction
        cardStyle.willChange = "transform";

        // ⚡ Cache layout metrics on enter to avoid thrashing in mousemove
        const rect = el.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        // ⚡ Calculate absolute document position to handle scrolling correctly
        left = rect.left + window.scrollX;
        top = rect.top + window.scrollY;

        // ⚡ Bolt: Hint browser to promote layer only during interaction
        cardStyle.setProperty("will-change", "transform");

        // ⚡ Bolt: Lazy attach listeners only when interacting
        card.addEventListener("mousemove", onMouseMove);
        card.addEventListener("mouseleave", onMouseLeave);
      }

      card.addEventListener("mouseenter", onMouseEnter);
    });
  }

  // Re-run on page transitions (astro:page-load fires on initial load too)
  document.addEventListener("astro:page-load", initTiltCards);
</script>

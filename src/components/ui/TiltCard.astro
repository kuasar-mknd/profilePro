---
interface Props {
  class?: string;
  maxTilt?: number;
  scale?: number;
  perspective?: number;
}

const {
  class: className = "",
  maxTilt = 10,
  scale = 1.02,
  perspective = 1000,
} = Astro.props;
---

<div
  class:list={["tilt-card", className, "contain-layout"]}
  data-max-tilt={maxTilt}
  data-scale={scale}
  data-perspective={perspective}
  style="contain: layout style;"
>
  <div class="tilt-shine"></div>
  <slot />
</div>

<script>
  /**
   * ⚡ Bolt: TiltCard performance optimization
   * - Lazy listener attachment: 'mousemove' is only attached during interaction
   * - Caches DOM references
   * - RAF throttling
   */
  function initTiltCards() {
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

    const cards = document.querySelectorAll(
      ".tilt-card:not(.tilt-initialized)",
    );

    cards.forEach((card) => {
      const el = card as HTMLElement;
      const maxTilt = Number(el.dataset.maxTilt) || 10;
      card.classList.add("tilt-initialized");

      // ⚡ Cache the style object reference to avoid repeated lookups
      const cardStyle = el.style;

      let bounds: DOMRect | null = null;
      let frameId: number | null = null;
      let targetX = 0;
      let targetY = 0;

      function update() {
        if (!bounds) return;

        // ⚡ Pre-calculate center coordinates using cached bounds
        const centerX = bounds.width * 0.5;
        const centerY = bounds.height * 0.5;

        // ⚡ Calculate relative position
        const relativeX = targetX - bounds.left - centerX;
        const relativeY = targetY - bounds.top - centerY;

        // ⚡ Calculate rotation with division by center values
        const rotateX = (relativeY / centerY) * -maxTilt;
        const rotateY = (relativeX / centerX) * maxTilt;

        // ⚡ Set CSS custom properties using cached style reference
        cardStyle.setProperty("--rotate-x", `${rotateX}deg`);
        cardStyle.setProperty("--rotate-y", `${rotateY}deg`);

        frameId = null;
      }

      function onMouseMove(e: MouseEvent) {
        if (!bounds) return;

        targetX = e.clientX;
        targetY = e.clientY;

        // ⚡ Use requestAnimationFrame to throttle visual updates
        if (!frameId) {
          frameId = requestAnimationFrame(update);
        }
      }

      function onMouseLeave() {
        // ⚡ Cancel pending frame
        if (frameId) {
          cancelAnimationFrame(frameId);
          frameId = null;
        }

        // ⚡ Reset styles
        cardStyle.setProperty("--rotate-x", "0deg");
        cardStyle.setProperty("--rotate-y", "0deg");
        // ⚡ Bolt: Remove will-change to save GPU memory when not interacting
        cardStyle.removeProperty("will-change");

        bounds = null;

        // ⚡ Bolt: Cleanup high-frequency listeners when not needed
        card.removeEventListener("mousemove", onMouseMove);
        card.removeEventListener("mouseleave", onMouseLeave);
      }

      function onMouseEnter() {
        // ⚡ Bolt: Promote to composite layer only on interaction
        cardStyle.willChange = "transform";

        // ⚡ Cache layout metrics on enter to avoid thrashing in mousemove
        bounds = el.getBoundingClientRect();

        // ⚡ Bolt: Hint browser to promote layer only during interaction
        cardStyle.setProperty("will-change", "transform");

        // ⚡ Bolt: Lazy attach listeners only when interacting
        card.addEventListener("mousemove", onMouseMove);
        card.addEventListener("mouseleave", onMouseLeave);
      }

      card.addEventListener("mouseenter", onMouseEnter);
    });
  }

  // Re-run on page transitions (astro:page-load fires on initial load too)
  document.addEventListener("astro:page-load", initTiltCards);
</script>

---
interface Props {
  class?: string;
  maxTilt?: number;
  scale?: number;
  perspective?: number;
}

const {
  class: className = "",
  maxTilt = 10,
  scale = 1.02,
  perspective = 1000,
} = Astro.props;
---

<div
  class:list={["tilt-card", className]}
  data-max-tilt={maxTilt}
  data-scale={scale}
  data-perspective={perspective}
>
  <div class="tilt-shine"></div>
  <slot />
</div>

<script>
  /**
   * ⚡ Bolt: TiltCard performance optimization
   * Caches DOM references and pre-calculates values to reduce overhead
   * during frequent mousemove events.
   */
  function initTiltCards() {
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

    const cards = document.querySelectorAll(
      ".tilt-card:not(.tilt-initialized)",
    );

    cards.forEach((card) => {
      const el = card as HTMLElement;
      const maxTilt = Number(el.dataset.maxTilt) || 10;
      let rect: DOMRect | null = null;
      let frameId: number | null = null;

      card.classList.add("tilt-initialized");

      // ⚡ Cache the style object reference to avoid repeated lookups
      const cardStyle = el.style;

      // ⚡ Cache layout metrics on hover start to avoid thrashing in mousemove
      card.addEventListener("mouseenter", () => {
        rect = el.getBoundingClientRect();
      });

      card.addEventListener("mousemove", (e) => {
        // Guard: If we don't have the rect yet (rare), fetch it once
        if (!rect) rect = el.getBoundingClientRect();

        const event = e as MouseEvent;

        // ⚡ Bolt: Debounce visual updates to screen refresh rate
        if (frameId) return;

        frameId = requestAnimationFrame(() => {
          if (!rect) return; // TS guard

          // ⚡ Pre-calculate center coordinates (cached in closure if we wanted, but cheap here)
          const centerX = rect.width * 0.5;
          const centerY = rect.height * 0.5;

          // ⚡ Calculate relative position using cached rect
          const relativeX = event.clientX - rect.left - centerX;
          const relativeY = event.clientY - rect.top - centerY;

          // ⚡ Calculate rotation with division by center values
          const rotateX = (relativeY / centerY) * -maxTilt;
          const rotateY = (relativeX / centerX) * maxTilt;

          // ⚡ Set CSS custom properties
          cardStyle.setProperty("--rotate-x", `${rotateX}deg`);
          cardStyle.setProperty("--rotate-y", `${rotateY}deg`);

          frameId = null;
        });
      });

      card.addEventListener("mouseleave", () => {
        if (frameId) {
          cancelAnimationFrame(frameId);
          frameId = null;
        }

        // ⚡ Use cached style reference
        cardStyle.setProperty("--rotate-x", "0deg");
        cardStyle.setProperty("--rotate-y", "0deg");

        // Clear cached rect
        rect = null;
      });
    });
  }

  // Run on initial load
  initTiltCards();

  // Re-run on page transitions
  document.addEventListener("astro:page-load", initTiltCards);
</script>

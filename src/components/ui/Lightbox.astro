---
/**
 * Lightbox.astro - Modal plein √©cran pour visualiser les images
 *
 * Fonctionnalit√©s:
 * - Navigation clavier (‚Üê/‚Üí/Escape)
 * - Swipe tactile
 * - Compteur d'images
 * - Animation smooth
 */
---

<div
  id="lightbox"
  class="lightbox"
  aria-hidden="true"
  role="dialog"
  aria-modal="true"
  aria-label="Galerie photos en plein √©cran"
>
  <div class="lightbox-backdrop"></div>

  <button
    type="button"
    class="lightbox-close group"
    aria-label="Fermer"
    title="Fermer (Esc)"
    aria-keyshortcuts="Escape"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
    <span
      class="hidden md:block absolute top-full right-0 mt-2 text-xs font-medium text-white/70 bg-black/50 px-2 py-0.5 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap"
      aria-hidden="true">Esc</span
    >
  </button>

  <button
    type="button"
    class="lightbox-nav lightbox-prev group"
    aria-label="Image pr√©c√©dente"
    title="Image pr√©c√©dente (‚Üê)"
    aria-keyshortcuts="ArrowLeft"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="32"
      height="32"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
    <span
      class="hidden md:block absolute top-full left-1/2 -translate-x-1/2 mt-2 text-xs font-medium text-white/70 bg-black/50 px-2 py-0.5 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap"
      aria-hidden="true">‚Üê</span
    >
  </button>

  <div class="lightbox-content">
    <img src="" alt="" class="lightbox-image" decoding="async" />
  </div>

  <div class="lightbox-loader" aria-hidden="true">
    <div class="spinner"></div>
  </div>

  <button
    type="button"
    class="lightbox-nav lightbox-next group"
    aria-label="Image suivante"
    title="Image suivante (‚Üí)"
    aria-keyshortcuts="ArrowRight"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="32"
      height="32"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
    <span
      class="hidden md:block absolute top-full left-1/2 -translate-x-1/2 mt-2 text-xs font-medium text-white/70 bg-black/50 px-2 py-0.5 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap"
      aria-hidden="true">‚Üí</span
    >
  </button>

  <div class="lightbox-counter" aria-live="polite" aria-atomic="true">
    <span class="sr-only">Image </span>
    <span class="lightbox-current">1</span>
    <span aria-hidden="true"> / </span>
    <span class="sr-only"> sur </span>
    <span class="lightbox-total">1</span>
  </div>
  <!-- üé® Palette: Announcement region for image alt text -->
  <div
    id="lightbox-announcer"
    class="sr-only"
    aria-live="polite"
    aria-atomic="true"
  >
  </div>
</div>

<style>
  .lightbox {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition:
      opacity 0.3s ease,
      visibility 0.3s ease;
  }

  .lightbox[aria-hidden="false"] {
    opacity: 1;
    visibility: visible;
  }

  .lightbox-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
  }

  .lightbox-close {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    z-index: 10;
    padding: 0.75rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .lightbox-close:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
  }

  .lightbox-close:focus-visible {
    outline: none;
    box-shadow:
      0 0 0 2px var(--color-pacamara-accent),
      0 0 0 4px rgba(0, 0, 0, 0.5);
  }

  .lightbox-content {
    position: relative;
    z-index: 5;
    max-width: 90vw;
    max-height: 85vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .lightbox-image {
    max-width: 100%;
    max-height: 85vh;
    object-fit: contain;
    border-radius: 0.75rem;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    transform: scale(0.95);
    opacity: 0;
    transition:
      transform 0.3s ease,
      opacity 0.3s ease;
  }

  .lightbox[aria-hidden="false"] .lightbox-image {
    transform: scale(1);
    opacity: 1;
  }

  .lightbox-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 10;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .lightbox-nav:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-50%) scale(1.1);
  }

  .lightbox-nav:focus-visible {
    outline: none;
    box-shadow:
      0 0 0 2px var(--color-pacamara-accent),
      0 0 0 4px rgba(0, 0, 0, 0.5);
  }

  .lightbox-prev {
    left: 1.5rem;
  }

  .lightbox-next {
    right: 1.5rem;
  }

  .lightbox-counter {
    position: absolute;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    padding: 0.5rem 1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 9999px;
    color: white;
    font-size: 0.875rem;
    font-weight: 500;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .lightbox-nav {
      padding: 0.75rem;
    }

    .lightbox-prev {
      left: 0.5rem;
    }

    .lightbox-next {
      right: 0.5rem;
    }

    .lightbox-close {
      top: 1rem;
      right: 1rem;
    }
  }

  .lightbox-loader {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .lightbox.loading .lightbox-loader {
    opacity: 1;
  }

  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
</style>

<script>
  class Lightbox {
    private lightbox: HTMLElement;
    private image: HTMLImageElement;
    private currentSpan: HTMLElement;
    private totalSpan: HTMLElement;
    private announcer: HTMLElement;
    private galleryElements: HTMLImageElement[] = [];
    private currentIndex: number = 0;
    // ‚ö° Bolt: Cache to prevent GC of preloaded images
    private preloadCache: HTMLImageElement[] = [];
    // ‚ö° Bolt: Set to track already preloaded URLs and avoid redundant requests
    private preloadedUrls = new Set<string>();
    private touchStartX: number = 0;
    private touchEndX: number = 0;
    private focusableElements: HTMLElement[] = [];
    private firstFocusableElement: HTMLElement | null = null;
    private lastFocusableElement: HTMLElement | null = null;
    private boundKeyHandler: (e: KeyboardEvent) => void;
    private boundClickHandler: (e: MouseEvent) => void;
    private boundDelegatedKeyHandler: (e: KeyboardEvent) => void;

    constructor() {
      this.boundKeyHandler = this.handleKeyboard.bind(this);
      this.boundClickHandler = this.handleClick.bind(this);
      this.boundDelegatedKeyHandler = this.handleDelegatedKeyboard.bind(this);
      this.lightbox = document.getElementById("lightbox")!;
      this.image = this.lightbox.querySelector(
        ".lightbox-image",
      ) as HTMLImageElement;
      this.currentSpan = this.lightbox.querySelector(".lightbox-current")!;
      this.totalSpan = this.lightbox.querySelector(".lightbox-total")!;
      this.announcer = this.lightbox.querySelector("#lightbox-announcer")!;

      // Identify focusable elements
      const focusableSelector =
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
      this.focusableElements = Array.from(
        this.lightbox.querySelectorAll(focusableSelector),
      ) as HTMLElement[];
      this.firstFocusableElement = this.focusableElements[0];
      this.lastFocusableElement =
        this.focusableElements[this.focusableElements.length - 1];

      this.init();
    }

    private init() {
      // Close button
      this.lightbox
        .querySelector(".lightbox-close")
        ?.addEventListener("click", () => this.close());

      // Backdrop click
      this.lightbox
        .querySelector(".lightbox-backdrop")
        ?.addEventListener("click", () => this.close());

      // Navigation
      this.lightbox
        .querySelector(".lightbox-prev")
        ?.addEventListener("click", () => this.prev());
      this.lightbox
        .querySelector(".lightbox-next")
        ?.addEventListener("click", () => this.next());

      // Keyboard
      document.addEventListener("keydown", this.boundKeyHandler);

      // Touch events for swipe
      this.lightbox.addEventListener(
        "touchstart",
        (e) => this.handleTouchStart(e),
        { passive: true },
      );
      this.lightbox.addEventListener(
        "touchend",
        (e) => this.handleTouchEnd(e),
        { passive: true },
      );

      // ‚ö° Bolt: Event Delegation for Gallery Images
      // Listens on document instead of attaching listeners to every image
      document.addEventListener("click", this.boundClickHandler);
      // ‚ö° Bolt: Accessibility - Handle keyboard activation for images
      document.addEventListener("keydown", this.boundDelegatedKeyHandler);

      // ‚ö° Bolt: Cache gallery elements once on init
      this.collectImages();
    }

    /**
     * ‚ö° Bolt: Delegated click handler
     * Handles clicks on any element with data-gallery-image
     */
    private handleClick(e: MouseEvent) {
      const target = e.target as HTMLElement;
      // Handle direct clicks or clicks on children (though img usually doesn't have children)
      const galleryImage = target.closest(
        "[data-gallery-image]",
      ) as HTMLElement;

      if (galleryImage) {
        this.activateImage(galleryImage);
      }
    }

    /**
     * ‚ö° Bolt: Delegated keyboard handler
     * Handles Enter/Space on any element with data-gallery-image
     */
    private handleDelegatedKeyboard(e: KeyboardEvent) {
      if (e.key === "Enter" || e.key === " ") {
        const target = e.target as HTMLElement;
        const galleryImage = target.closest(
          "[data-gallery-image]",
        ) as HTMLElement;

        if (galleryImage) {
          e.preventDefault(); // Prevent page scroll on Space
          this.activateImage(galleryImage);
        }
      }
    }

    private activateImage(galleryImage: HTMLElement) {
      // ‚ö° Bolt: Use cached elements for O(1) lookup
      const index = this.galleryElements.indexOf(
        galleryImage as HTMLImageElement,
      );

      if (index !== -1) {
        this.open(index, galleryImage);
      }
    }

    private collectImages() {
      // ‚ö° Bolt: Cache DOM elements once at init
      const elements = document.querySelectorAll("[data-gallery-image]");
      this.galleryElements = Array.from(elements) as HTMLImageElement[];
    }

    private triggerElement: HTMLElement | null = null;

    public open(index: number, trigger?: HTMLElement) {
      if (trigger) this.triggerElement = trigger;
      this.currentIndex = index;
      this.updateImage();
      this.lightbox.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      // üé® Palette: Trap focus and context using inert
      this.toggleInert(true);

      // Move focus to close button
      setTimeout(() => {
        const closeBtn = this.lightbox.querySelector(
          ".lightbox-close",
        ) as HTMLElement;
        closeBtn?.focus();
      }, 100);
    }

    public close() {
      this.lightbox.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";

      // üé® Palette: Restore access to main content
      this.toggleInert(false);

      // Return focus to trigger
      if (this.triggerElement) {
        this.triggerElement.focus();
        this.triggerElement = null;
      }
    }

    /**
     * üé® Palette: Toggles inert and aria-hidden on background content
     * This ensures screen readers and keyboard navigation stay within the lightbox.
     */
    private toggleInert(enable: boolean) {
      const selectors = [
        "#main-header",
        "#main-content",
        "footer",
        "#back-to-top",
        ".skip-link",
      ];
      const elements = document.querySelectorAll(selectors.join(", "));

      elements.forEach((el) => {
        if (enable) {
          el.setAttribute("inert", "");
          el.setAttribute("aria-hidden", "true");
        } else {
          el.removeAttribute("inert");
          el.removeAttribute("aria-hidden");
        }
      });
    }

    public next() {
      this.currentIndex = (this.currentIndex + 1) % this.galleryElements.length;
      this.updateImage();
    }

    public prev() {
      this.currentIndex =
        (this.currentIndex - 1 + this.galleryElements.length) %
        this.galleryElements.length;
      this.updateImage();
    }

    private updateImage() {
      // ‚ö° Bolt: Read properties on demand
      const currentElement = this.galleryElements[this.currentIndex];
      const src = currentElement.currentSrc || currentElement.src;
      const alt = currentElement.alt || "";

      this.image.src = src;
      this.image.alt = alt || `Image ${this.currentIndex + 1}`;
      this.currentSpan.textContent = String(this.currentIndex + 1);
      this.totalSpan.textContent = String(this.galleryElements.length);

      // üé® Palette: Announce image description
      if (this.announcer) {
        this.announcer.textContent = alt || "Image sans description";
      }

      // Loading state
      this.lightbox.classList.add("loading");
      this.image.style.opacity = "0";

      this.image.onload = () => {
        this.lightbox.classList.remove("loading");
        this.image.style.opacity = "1";
        // ‚ö° Bolt: Preload adjacent images after current one loads
        this.preloadAdjacentImages();
      };
    }

    /**
     * ‚ö° Bolt: Predictive Preloading
     * Silently fetches the next and previous images to ensure instant navigation.
     */
    private preloadAdjacentImages() {
      const total = this.galleryElements.length;
      if (total <= 1) return;

      const nextIndex = (this.currentIndex + 1) % total;
      const prevIndex = (this.currentIndex - 1 + total) % total;

      this.preloadImage(this.getImageSrc(nextIndex));
      this.preloadImage(this.getImageSrc(prevIndex));
    }

    private getImageSrc(index: number): string {
      const el = this.galleryElements[index];
      return el.currentSrc || el.src;
    }

    private preloadImage(src: string) {
      // ‚ö° Bolt: Optimization - Check both validity and duplication
      if (!src || this.preloadedUrls.has(src)) return;

      this.preloadedUrls.add(src);
      const img = new Image();
      img.decoding = "async";
      img.src = src;

      // ‚ö° Bolt: Store reference to prevent garbage collection cancelling the request
      this.preloadCache.push(img);

      // Keep cache small to balance memory usage
      if (this.preloadCache.length > 10) {
        // Note: We don't remove from preloadedUrls Set because we still want to avoid
        // re-triggering the request even if the image object is dropped from our GC hold.
        // The browser cache should handle the actual asset if needed again.
        this.preloadCache.shift();
      }
    }

    private handleKeyboard(e: KeyboardEvent) {
      // Only handle modal navigation keys if lightbox is open
      if (this.lightbox.getAttribute("aria-hidden") === "true") return;

      // Focus trap
      if (e.key === "Tab") {
        if (e.shiftKey) {
          if (document.activeElement === this.firstFocusableElement) {
            e.preventDefault();
            this.lastFocusableElement?.focus();
          }
        } else {
          if (document.activeElement === this.lastFocusableElement) {
            e.preventDefault();
            this.firstFocusableElement?.focus();
          }
        }
      }

      switch (e.key) {
        case "Escape":
          this.close();
          break;
        case "ArrowLeft":
          this.prev();
          break;
        case "ArrowRight":
          this.next();
          break;
      }
    }

    private handleTouchStart(e: TouchEvent) {
      this.touchStartX = e.changedTouches[0].screenX;
    }

    private handleTouchEnd(e: TouchEvent) {
      this.touchEndX = e.changedTouches[0].screenX;
      this.handleSwipe();
    }

    private handleSwipe() {
      const threshold = 50;
      const diff = this.touchStartX - this.touchEndX;

      if (Math.abs(diff) > threshold) {
        if (diff > 0) {
          this.next();
        } else {
          this.prev();
        }
      }
    }

    public destroy() {
      document.removeEventListener("keydown", this.boundKeyHandler);
      document.removeEventListener("click", this.boundClickHandler);
      document.removeEventListener("keydown", this.boundDelegatedKeyHandler);
      // ‚ö° Bolt: Clear cache references to allow GC
      this.preloadCache = [];
      this.preloadedUrls.clear();
      this.galleryElements = [];
    }
  }

  /**
   * ‚ö° Bolt: Singleton pattern for Lightbox with proper cleanup
   * Ensures the Lightbox instance is tied to the current DOM elements
   * and previous listeners are removed before creating a new one.
   */
  let lightboxInstance: Lightbox | null = null;

  function initLightbox() {
    // ‚ö° Clean up previous instance to prevent listener leaks or stale DOM refs
    if (lightboxInstance) {
      lightboxInstance.destroy();
    }

    // Create fresh instance for the new page content
    lightboxInstance = new Lightbox();
  }

  // ‚ö° Bolt: Removed redundant DOMContentLoaded listener
  // astro:page-load handles both initial load and subsequent navigations
  document.addEventListener("astro:page-load", initLightbox);
</script>

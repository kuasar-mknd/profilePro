---
interface Props {
  direction?: "up" | "left" | "right" | "scale";
  delay?: number;
  threshold?: number;
  class?: string;
}

const {
  direction = "up",
  delay = 0,
  threshold = 0.1,
  class: className = "",
} = Astro.props;

const directionClass = {
  up: "",
  left: "from-left",
  right: "from-right",
  scale: "scale-in",
}[direction];

const staggerClass =
  delay > 0 ? `stagger-${Math.min(Math.ceil(delay * 10), 6)}` : "";
---

<div
  class:list={["reveal-on-scroll", directionClass, staggerClass, className]}
  data-threshold={threshold}
  class="[contain:layout_paint]"
>
  <slot />
</div>

<script>
  /**
   * ⚡ Bolt: Cached IntersectionObserver singleton
   * Reuses a single observer across page transitions to reduce memory usage
   * and avoid creating multiple observers for the same purpose.
   */
  let cachedScrollRevealObserver: IntersectionObserver | null = null;

  function getScrollRevealObserver(): IntersectionObserver {
    // ⚡ Reuse existing observer instance
    if (cachedScrollRevealObserver) {
      return cachedScrollRevealObserver;
    }

    cachedScrollRevealObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const target = entry.target as HTMLElement;
            // ⚡ Bolt: Hint browser for layer promotion just before animation
            // This ensures smooth animation without keeping memory-heavy layers active when off-screen
            target.style.willChange = "opacity, transform";

            requestAnimationFrame(() => {
              target.classList.add("visible");
            });

            // ⚡ Bolt: Cleanup high-cost will-change property after animation
            target.addEventListener(
              "transitionend",
              () => {
                target.style.willChange = "auto";
              },
              { once: true },
            );

            cachedScrollRevealObserver?.unobserve(target);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "0px 0px -50px 0px",
      },
    );

    return cachedScrollRevealObserver;
  }

  function initScrollReveal() {
    const elements = document.querySelectorAll(
      ".reveal-on-scroll:not(.initialized)",
    );

    // Early return if no elements to process
    if (elements.length === 0) return;

    // Respect reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;

    if (prefersReducedMotion) {
      elements.forEach((el) => {
        el.classList.add("visible", "initialized");
        // Force immediate visibility styles
        (el as HTMLElement).style.opacity = "1";
        (el as HTMLElement).style.transform = "none";
      });
      return;
    }

    // ⚡ Get or create the singleton observer
    const observer = getScrollRevealObserver();

    elements.forEach((el) => {
      el.classList.add("initialized");
      observer.observe(el);
    });
  }

  // Run on initial load
  initScrollReveal();

  // Re-run on page transitions (Astro View Transitions)
  document.addEventListener("astro:page-load", initScrollReveal);

  // ⚡ Bolt: Cleanup stale observers on swap to prevent memory leaks
  document.addEventListener("astro:after-swap", () => {
    if (cachedScrollRevealObserver) {
      cachedScrollRevealObserver.disconnect();
    }
  });
</script>

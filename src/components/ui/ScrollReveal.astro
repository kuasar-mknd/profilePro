---
interface Props {
  direction?: "up" | "left" | "right" | "scale";
  delay?: number;
  threshold?: number;
  class?: string;
}

const {
  direction = "up",
  delay = 0,
  threshold = 0.1,
  class: className = "",
} = Astro.props;

const directionClass = {
  up: "",
  left: "from-left",
  right: "from-right",
  scale: "scale-in",
}[direction];

const staggerClass =
  delay > 0 ? `stagger-${Math.min(Math.ceil(delay * 10), 6)}` : "";
---

<div
  class:list={["reveal-on-scroll", directionClass, staggerClass, className]}
  data-threshold={threshold}
>
  <slot />
</div>

<script>
  // Initialize Intersection Observer for scroll reveal
  function initScrollReveal() {
    const elements = document.querySelectorAll(
      ".reveal-on-scroll:not(.initialized)",
    );

    // Respect reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;

    if (prefersReducedMotion) {
      elements.forEach((el) => {
        el.classList.add("visible", "initialized");
        // Force immediate visibility styles
        (el as HTMLElement).style.opacity = "1";
        (el as HTMLElement).style.transform = "none";
      });
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("visible");
            observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "0px 0px -50px 0px",
      },
    );

    elements.forEach((el) => {
      el.classList.add("initialized");
      observer.observe(el);
    });
  }

  // Run on initial load
  initScrollReveal();

  // Re-run on page transitions (Astro View Transitions)
  document.addEventListener("astro:page-load", initScrollReveal);
</script>

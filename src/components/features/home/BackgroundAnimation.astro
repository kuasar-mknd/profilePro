---

---

<div class="absolute inset-0 overflow-hidden -z-10 pointer-events-none">
  <!-- Blob 1: Behind "Connecter" (Top Left-ish) -->
  <div
    class="absolute top-[20%] left-[20%] w-[300px] h-[300px] bg-pacamara-secondary/20 rounded-full blur-[80px] mix-blend-screen dark:mix-blend-screen filter opacity-40 will-change-transform translate-z-0"
  >
  </div>

  <!-- Blob 2: Behind "Captiver" (Bottom Right-ish relative to text) -->
  <div
    class="absolute top-[35%] left-[55%] w-[300px] h-[300px] bg-pacamara-accent/20 rounded-full blur-[80px] mix-blend-screen dark:mix-blend-screen filter opacity-40 will-change-transform translate-z-0"
  >
  </div>

  <!-- Mouse Follower Blob (Subtle) -->
  <div
    id="mouse-blob"
    class="absolute w-[250px] h-[250px] bg-white/10 dark:bg-white/5 rounded-full blur-[60px] mix-blend-overlay transition-transform duration-100 ease-out opacity-0 will-change-transform translate-z-0"
    style="transform: translate(-50%, -50%);"
  >
  </div>
</div>

<script>
  /**
   * ⚡ Bolt: BackgroundAnimation Performance Optimizations
   * - Initialization guard to prevent duplicate listeners
   * - Reduced motion check for accessibility
   * - DOM caching for animation loop
   * - RAF throttling for mousemove
   */
  function initMouseBlob() {
    const blob = document.getElementById("mouse-blob");
    const container = blob?.parentElement;

    // ⚡ Early return guards
    if (!blob || !container) return;
    if (blob.dataset.initialized === "true") return;
    blob.dataset.initialized = "true";

    // ⚡ Skip for reduced motion preference
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      blob.style.display = "none";
      return;
    }

    let mouseX = 0;
    let mouseY = 0;
    let blobX = 0;
    let blobY = 0;
    let isVisible = false;

    // ⚡ Cache style reference
    const blobStyle = blob.style;

    // Smoothness factor (lower = smoother/slower)
    const ease = 0.08;

    // ⚡ RAF-throttled mousemove
    document.addEventListener(
      "mousemove",
      (e) => {
        const rect = container.getBoundingClientRect();
        // Calculate relative position
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        if (!isVisible) {
          isVisible = true;
          blobStyle.opacity = "1";
          // Initialize position to prevent jump
          blobX = mouseX;
          blobY = mouseY;
          requestAnimationFrame(animate);
        }
      },
      { passive: true },
    );

    // ⚡ Optimized animation loop with cached references
    function animate() {
      if (!isVisible) return;

      // Linear interpolation (lerp)
      const dx = mouseX - blobX;
      const dy = mouseY - blobY;

      blobX += dx * ease;
      blobY += dy * ease;

      // ⚡ Use cached style reference
      blobStyle.transform = `translate(${blobX}px, ${blobY}px) translate(-50%, -50%)`;

      // Stop loop if close enough to target
      if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
        isVisible = false;
        return;
      }

      requestAnimationFrame(animate);
    }
  }

  // Initialize
  initMouseBlob();
  document.addEventListener("astro:page-load", initMouseBlob);
</script>

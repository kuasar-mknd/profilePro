---

---

<div class="absolute inset-0 overflow-hidden -z-10 pointer-events-none">
  <!-- Blob 1: Behind "Connecter" (Top Left-ish) -->
  <div
    class="absolute top-[20%] left-[20%] w-[300px] h-[300px] bg-pacamara-secondary/20 rounded-full blur-[80px] mix-blend-screen dark:mix-blend-screen filter opacity-40 translate-z-0"
  >
  </div>

  <!-- Blob 2: Behind "Captiver" (Bottom Right-ish relative to text) -->
  <div
    class="absolute top-[35%] left-[55%] w-[300px] h-[300px] bg-pacamara-accent/20 rounded-full blur-[80px] mix-blend-screen dark:mix-blend-screen filter opacity-40 translate-z-0"
  >
  </div>

  <!-- Mouse Follower Blob (Subtle) -->
  <div
    id="mouse-blob"
    class="absolute w-[250px] h-[250px] bg-white/10 dark:bg-white/5 rounded-full blur-[60px] mix-blend-overlay transition-transform duration-100 ease-out opacity-0 translate-z-0"
    style="transform: translate(-50%, -50%);"
  >
  </div>
</div>

<script>
  /**
   * ⚡ Bolt: BackgroundAnimation Performance Optimizations
   * - Initialization guard to prevent duplicate listeners
   * - Reduced motion check for accessibility
   * - DOM caching for animation loop
   * - RAF throttling for mousemove
   * - Pre-calculated coordinates to avoid layout thrashing (getBoundingClientRect)
   * - Visibility Observer to pause mouse tracking when off-screen
   * - ⚡ Bolt: Dynamic will-change management to save GPU memory
   */

  let cleanup: (() => void) | null = null;

  function initMouseBlob() {
    // ⚡ Cleanup previous listeners if they exist (prevents memory leaks on navigation)
    if (cleanup) {
      cleanup();
      cleanup = null;
    }

    const blob = document.getElementById("mouse-blob");
    const container = blob?.parentElement;

    // ⚡ Early return guards
    if (!blob || !container) return;

    // ⚡ Skip for reduced motion preference
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      blob.style.display = "none";
      return;
    }

    let mouseX = 0;
    let mouseY = 0;
    let blobX = 0;
    let blobY = 0;
    let isVisible = false;
    let animationFrameId: number | null = null;

    // ⚡ Cache style reference
    const blobStyle = blob.style;

    // Smoothness factor (lower = smoother/slower)
    const ease = 0.08;

    // ⚡ Cache container metrics to avoid getBoundingClientRect() in hot path
    let containerLeft = 0;
    let containerTop = 0;

    const updateMetrics = () => {
      const rect = container.getBoundingClientRect();
      containerLeft = rect.left + window.scrollX;
      containerTop = rect.top + window.scrollY;
    };

    // Initial calculation
    updateMetrics();

    // ⚡ Bolt: Debounce resize to prevent layout thrashing
    let resizeTimeout: number | undefined;
    const onResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(updateMetrics, 200);
    };

    window.addEventListener("resize", onResize, { passive: true });

    // ⚡ Optimized mousemove handler
    const onMouseMove = (e: MouseEvent) => {
      // ⚡ FAST: Use page coordinates and cached offset
      // Eliminates forced reflows from getBoundingClientRect()
      mouseX = e.pageX - containerLeft;
      mouseY = e.pageY - containerTop;

      if (!isVisible) {
        isVisible = true;
        blobStyle.opacity = "1";
        // ⚡ Bolt: Hint browser for transform optimization only when needed
        blobStyle.willChange = "transform";
        // Initialize position to prevent jump
        blobX = mouseX;
        blobY = mouseY;
        animate();
      }
    };

    // ⚡ Optimized animation loop with cached references
    function animate() {
      if (!isVisible) return;

      // Linear interpolation (lerp)
      const dx = mouseX - blobX;
      const dy = mouseY - blobY;

      blobX += dx * ease;
      blobY += dy * ease;

      // ⚡ Use cached style reference
      // ⚡ Bolt: Use translate3d to force GPU layer promotion (hardware acceleration)
      blobStyle.transform = `translate3d(${blobX}px, ${blobY}px, 0) translate(-50%, -50%)`;

      // Stop loop if close enough to target
      if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
        isVisible = false;
        animationFrameId = null;
        // ⚡ Bolt: Release GPU memory when animation stops
        blobStyle.willChange = "auto";
        return;
      }

      animationFrameId = requestAnimationFrame(animate);
    }

    // ⚡ Bolt: Visibility Observer to pause mouse tracking when off-screen
    // Saves CPU/Battery by removing the high-frequency mousemove listener
    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];
        if (entry.isIntersecting) {
          document.addEventListener("mousemove", onMouseMove, {
            passive: true,
          });
        } else {
          document.removeEventListener("mousemove", onMouseMove);
          // Also stop any ongoing animation
          isVisible = false;
          blobStyle.opacity = "0"; // Fade out when off-screen
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          // ⚡ Bolt: Ensure will-change is reset when off-screen
          blobStyle.willChange = "auto";
        }
      },
      { rootMargin: "200px" }, // Start tracking slightly before it enters viewport
    );

    observer.observe(container);

    // Register cleanup function
    const onCleanup = () => {
      observer.disconnect();
      window.removeEventListener("resize", onResize);
      if (resizeTimeout) clearTimeout(resizeTimeout);
      document.removeEventListener("mousemove", onMouseMove);
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      // ⚡ Bolt: Reset will-change on cleanup
      blobStyle.willChange = "auto";

      // Remove self from swap event to prevent duplicates
      document.removeEventListener("astro:before-swap", onCleanup);
      cleanup = null;
    };

    cleanup = onCleanup;

    // Ensure cleanup runs on navigation (Astro View Transitions)
    document.addEventListener("astro:before-swap", onCleanup);
  }

  // Initialize only via event listener to avoid double execution on initial load
  document.addEventListener("astro:page-load", initMouseBlob);
</script>
